import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.SecretKey;
import java.io.*;
import java.nio.file.*;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.*;
import java.util.zip.*;

public class SecurePack {

    private static final String RECORD_FILE = "records.txt";
    private static final int AES_KEY_SIZE = 128; // 128 bits
    private static final int GCM_IV_LENGTH = 12; // 12 bytes
    private static final int GCM_TAG_LENGTH = 16; // 16 bytes

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        System.out.println("1: Crear empaquetado\n2: Desencriptar");
        int option = sc.nextInt();
        sc.nextLine(); // limpiar buffer

        if(option == 1) {
            createPackage();
        } else if(option == 2) {
            decryptPackage();
        } else {
            System.out.println("Opción inválida");
        }
    }

    // ================= CREAR EMPAQUETADO =================
    private static void createPackage() throws Exception {
        String folderPath = "data/comprimir";
        File folder = new File(folderPath);
        if(!folder.exists() || !folder.isDirectory()) {
            System.out.println("La carpeta data/comprimir no existe.");
            return;
        }

        Scanner sc = new Scanner(System.in);
        System.out.println("Ingresa una clave AES:");
        String password = sc.nextLine();
        SecretKey key = getAESKeyFromPassword(password);

        // Crear archivo temporal comprimido
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipOutputStream zos = new ZipOutputStream(baos);

        Map<String, String> fileChecksums = new HashMap<>();

        for(File file : Objects.requireNonNull(folder.listFiles())) {
            if(file.isFile()) {
                byte[] content = Files.readAllBytes(file.toPath());

                // Calcular checksum SHA-256
                String checksum = sha256(content);
                fileChecksums.put(file.getName(), checksum);

                // Comprimir archivo
                ZipEntry entry = new ZipEntry(file.getName());
                zos.putNextEntry(entry);
                zos.write(content);
                zos.closeEntry();
            }
        }
        zos.close();

        byte[] compressedData = baos.toByteArray();

        // Cifrar con AES-GCM
        byte[] iv = new byte[GCM_IV_LENGTH];
        new SecureRandom().nextBytes(iv);

        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH*8, iv);
        cipher.init(Cipher.ENCRYPT_MODE, key, spec);
        byte[] encrypted = cipher.doFinal(compressedData);

        // Crear ID único
        String packageId = UUID.randomUUID().toString();
        String packageFileName = "package_" + packageId + ".secure";

        // Guardar empaquetado final en raíz del proyecto
        try (FileOutputStream fos = new FileOutputStream(packageFileName)) {
            fos.write(iv);          // primero IV
            fos.write(encrypted);   // luego datos cifrados
        }

        // Guardar registros en archivo local
        try(PrintWriter pw = new PrintWriter(new FileWriter(RECORD_FILE, true))) {
            for(Map.Entry<String, String> e : fileChecksums.entrySet()) {
                pw.println(packageId + "," + e.getKey() + "," + e.getValue() + "," + sha256(password.getBytes()));
            }
        }

        System.out.println("Empaquetado creado: " + packageFileName);
    }

    // ================= DESENCRIPTAR EMPAQUETADO =================
    private static void decryptPackage() throws Exception {
        Scanner sc = new Scanner(System.in);
        System.out.println("Ingresa el nombre del archivo empaquetado (ej: package_xxx.secure):");
        String packageFileName = sc.nextLine();

        System.out.println("Ingresa la clave AES:");
        String password = sc.nextLine();
        SecretKey key = getAESKeyFromPassword(password);

        // Extraer el ID desde el nombre del archivo
        String packageId = packageFileName.replace("package_", "").replace(".secure", "");

        // Leer archivo empaquetado
        byte[] fileBytes = Files.readAllBytes(Paths.get(packageFileName));
        byte[] iv = Arrays.copyOfRange(fileBytes, 0, GCM_IV_LENGTH);
        byte[] encrypted = Arrays.copyOfRange(fileBytes, GCM_IV_LENGTH, fileBytes.length);

        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH*8, iv);
        cipher.init(Cipher.DECRYPT_MODE, key, spec);

        byte[] decompressedBytes;
        try {
            decompressedBytes = cipher.doFinal(encrypted);
        } catch(Exception e) {
            System.out.println("Clave incorrecta o archivo corrupto.");
            return;
        }

        // Crear carpeta de salida: data/descomprimido/(packageId)/
        File outDir = new File("data/descomprimido/" + packageId);
        outDir.mkdirs();

        // Extraer archivos de ZIP
        ByteArrayInputStream bais = new ByteArrayInputStream(decompressedBytes);
        ZipInputStream zis = new ZipInputStream(bais);
        ZipEntry entry;
        while((entry = zis.getNextEntry()) != null) {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[1024];
            int len;
            while((len = zis.read(buffer)) > 0) {
                baos.write(buffer, 0, len);
            }
            byte[] content = baos.toByteArray();
            zis.closeEntry();

            // Verificar checksum contra archivo local
            String storedHash = findRecord(packageId, entry.getName(), sha256(password.getBytes()));
            if(storedHash == null) {
                System.out.println("Archivo " + entry.getName() + " no registrado o clave incorrecta.");
                continue;
            }
            String checksum = sha256(content);
            if(!checksum.equals(storedHash)) {
                System.out.println("Archivo " + entry.getName() + " corrupto!");
                continue;
            }

            // Guardar archivo restaurado
            Files.write(Paths.get(outDir.getPath(), entry.getName()), content);
            System.out.println("Archivo restaurado: " + outDir.getPath() + "/" + entry.getName());
        }
        zis.close();
    }

    // ================= FUNCIONES AUXILIARES =================
    private static SecretKey getAESKeyFromPassword(String password) throws Exception {
        byte[] keyBytes = Arrays.copyOf(password.getBytes("UTF-8"), AES_KEY_SIZE/8);
        return new SecretKeySpec(keyBytes, "AES");
    }

    private static String sha256(byte[] data) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(data);
        StringBuilder sb = new StringBuilder();
        for(byte b : hash) sb.append(String.format("%02x", b));
        return sb.toString();
    }

    private static String findRecord(String packageId, String fileName, String passwordHash) throws Exception {
        File f = new File(RECORD_FILE);
        if(!f.exists()) return null;
        try(BufferedReader br = new BufferedReader(new FileReader(f))) {
            String line;
            while((line = br.readLine()) != null) {
                String[] parts = line.split(",");
                if(parts.length == 4 && parts[0].equals(packageId) && parts[1].equals(fileName) && parts[3].equals(passwordHash)) {
                    return parts[2]; // devuelve checksum
                }
            }
        }
        return null;
    }
}